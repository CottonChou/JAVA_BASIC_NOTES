## 三次握手

TCP的三次握手是为了在两台计算机之间建立一条全双工的通道的连接，会占用两个计算机之间的通信线路。直到背一方或者双方关闭为止。TCP报头里面的拓展字段有 6 bit 的FLAG位。其中跟握手相关的有`SYN`(Synchronized Sequence Number)用作建立连接的同步信号,`ACK`(Ackonwledgement),用来对收到的数据进行确认`FIN`表示后面没有数据，表示结束。

最开始的的时候客户端和服务器都是`LISTENING`。

- **第一次握手**建立连接的时候，客户端发动一个数据包将SYN位置为1，表示希望建立连接，并且初始化一个序列号`seq`发送给server，此时客户端的状态进入`SYN_WAIT`
- **第二次握手**就是Server收到客户端的请求,通过STN=1知道这是要建立连接，于是发送一个响应包并将`SYN`位`ACK`位置为1，并且自己`ack（确认序列号）`必须是客户端发过来的`seq＋1`，表示收到了客户端的SYN，此时Server进入`SYN_REVD`状态。
- **第三次握手**，客户端收到服务器的响应包，检查ACK确认序列号是否是发送的`seq+1`，需要对响应包进行确认，确认包将ACK位置为1，确认序列号等于对方发来的序列号`seq+1`，自己的序列号`seq+1`，发送给服务器。此时进入`ESTABLISHED`状态。服务器此时检查收到的ACK和确认序列号,也进入`ESTABLISHED`状态，完成三次握手，连接建立。

```json
Client(send_wait)>>>>>>>>>>[SYN=1,Seq=x]>>>>>>>>>>>>>>>>>>>>Server

Client<<<<<<<<<<<<<<<<<[SYN=1,ACK=1,Seq=y,ack=x+1]<<<<<<<<<<Server(syn_revd)

Client(established)>>>>>[ACK=1,Seq=x+1,ack=y+1]>>>>>>>>>>>>>>Server
```

> 总结：syn是请求同步位，ack确认同步位，seq自己的序列号，，ackNum 确认对方发来的seq。

**可以两次握手吗？**

不可以。

三次连接第一是防止因为出现网络超时出现脏连接。

TTL网络报文的生存时间超过TCP请求的超时时间，假设两次握手可以建立建立。假设客户端发送一个超时的连接暂时没有到达服务器，此时在发送一个正常的连接和服务器通信后断开。断开连接后假设超时的连接到了服务器，此时服务器以为是新来建立连接的，确认建立连接。然后此时客户端不是SYN_SEND的状态，不会理会服务器的确认数据，这导致知识服务器单方面的建立了连接，浪费了资源。如果是三次握手的话，服务器会因为长时间没有收到客户端的这一次回复而导致连接建立失败。

其次就是在第一次握手服务器仅仅是知道了客户端可以发送数据的能力，如果自己发送出去的信息没有得到回复，服务器此时无法证明自己的发送能力和客户端的接受能力是正常的。还有就是双方的初始序列号也没有得到交换。

**可以四次握手吗？**

三次都可以，四次当然可以了。就是降低了传输的效率。本来现在TCP被人诟病的就是性能不好。

四次握手意思就是第二次握手的时候服务器只发送ACK和ACKNum,再发送一次自己的SYN和自己初始化SEQ序列号，显然这是可以合并为一次的。

**如果已经建立了连接，客户端故障了怎么办？**

服务端每次收到客户端的请求都会复位一个计时器，时间通常是2小时，若两个小时还没有收到客户端的消息，就会发送一个探测报文段，每隔75秒发一次，若一连10个报文段都没有响应，就认定客户端出现了故障，连接关闭。

现在也有将这种机制放在了应用层，定期发送心跳包来检测，一旦不对就回收连接。

**初始序列号是什么**

双方各自随机选择一个32位的数字作为发送数据的初始序列号，以后每次发动数据都是以这个数字为起点对发送的数据进行编号，以便于对方可以知道确认什么样的数据是合法的。

## 四次挥手

四次回收用来断开双方的连接.

- **第一次挥手**：Client将FIN置为1，发送一个Seq给Server，进入FIN_WAIT_1状态。
- **第二次挥手**：Server收到FIN后，发送一个ACK，ackNum = Seq + 1,进入CLOSE_WAIT状态。此时客户端没有要发送的数据了，但是可以接受服务器的消息.此时客户端处于FIN_WAIT_2。
- **第三次挥手**：此时服务器需要处理完数据，再发送一个FIN包，ACK=1,Ack = ack = seq+1.进入last_ack状态。
- **第四次挥手**：客户端收到服务的FIN后，进入TIME_WAIT状态，接着将ACK置为1，发送一个确认包给服务器，服务器收到后，进入closed状态，不再发送数据。客户端等待2*MSL（报文段最长寿命）时间，也进入closed状态。

```json
C(fin_wait_1)>>>>>>>>>>[FIN=1,Seq=x]>>>>>>>>S

C<<<<<<<[ACK=1,ack=x+1,seq=y1]<<<<<<<<<<<<<<<<S(close_wait)

c<<<<<<<[FIN=1,ACK=1,ack=x+1,seq=y2]<<<<<<<<<<<S(close)

c(close)>>>>>>>[ACK=1,Seq=x+1,ack=y2+1]>>>>>>>>>>>>>>>>S
```

**为什么不能把服务器的第二次挥手和第三次挥手的ACK和FIN合并起来，变为三次挥手?**

因为服务器收到客户端断开连接的请求，可能还有数据没有处理完毕，此时先确认，表示接收到了断开连接的请求，等处理完了之后再发送一个FIN包。

**TIME_WAIT的意义是什么？**

为了保证被动关闭放能够顺利进入closed状态。假设客户端的最后一次ACK没有成功的发送给了服务器，此时服务器会以为是客户端没有收到自己之前的消息，会再发送一次FIN_ACK,客户端收到第二次的三次挥手，会继续确认一次。并重新计时。

如果没有这个等待时间，服务器没有收到这个消息，四次挥手的ACK消息如果丢了，这回导致对方一直无法正常关闭。

## TCP如何实现流量控制？

在TCP的首部有一个窗口字段，占两个字节。窗口字段用来控制对方发送的数据量，单位是字节。TCP连接的一端根据设置的缓存空间大小确定自己的接受窗口大小，然后通知对方以确定对方发送窗口的上限。

发送窗口的上限不仅仅受接收方窗口大小限制，还有拥塞窗口。拥塞窗口就是网络传输的能力，取二者之间的最小值。

**什么是零窗口，接收窗口0会怎么样**

如果接收方没有能力接收数据，就会将接收窗口设置为0，这时发送方必须暂停发送数据，但是会启动一个持续计时器(persistence timer)，到期后发送一个大小为1字节的探测数据包，以查看接收窗口状态。如果接收方能够接收数据，就会在返回的报文中更新接收窗口大小，恢复数据传送。

****

## TCP的拥塞控制如何实现的？

![image-20210417222415034](ComputerNetWork.assets/image-20210417222415034.png)

拥塞控制主要由四个算法组成。

**慢启动，拥塞避免，快重传，快恢复**

- 慢启动：开始发送数据的时候，先把拥塞窗口cwnd设置为1，每次收到新的确认报文，窗口值翻倍。说是慢启动，其实cwnd的值增长的特别快，发送方的速度增快过快，从而发生网络拥塞的可能性更高，设置一个慢开始门限ssthresh,如果出现了超时，ssthresh = cwnd/2.然后重新开始慢开始。

- 拥塞避免：如果cwnd>=ssthresh，每次窗口值只加1.
- 快重传：快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。
- 快恢复：当发送方连续收到三个重复确认时，就把慢开始门限减半，然后执行拥塞避免算法。不执行慢开始算法的原因：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方认为现在网络可能没有出现拥塞。

## TCP与UDP的区别

- TCP是面向连接的，UDP是无连接的；

- TCP是可靠的，UDP是不可靠的；

- TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；

- TCP是面向字节流的，UDP是面向报文的；

- TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信；

- TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大；

**无连接和有连接的区别**

无连接属于数据报服务，每个数据包含有目标地址，网络尽最大的努力交付数据，不保证不丢失，不保证先后顺序，不保证在时限内交付。

## HTTP和HTTPS的区别

首先端口号不同。HTTP是80端口，HTTP是443端口。

HTTP是明文传输，HTTPS运行于SSL层之上，添加了加密和认证机制，更加安全。加密解密带来了CPU的开销。HTTPS需要证书。

**HTTPS的连接过程**

- 客户端向服务端发送请求，发送自己支持的加密算法，和hash算法。
- 服务器根据客户端发来的加密算法选择一套适合双方的，将自己身份信息以证书的形式发送给客户端，证书里面包括了服务器自己的非对称加密的公钥，证书的颁发机构等信息。
- 客户端验证服务器的合法性，验证证书是否过期，CA机构是否可靠，收到的公钥是否能够正确解开发行者的 数字签名，服务器的域名和证书上的域名是否一致。
- 如果证书受信任或者不受信任，客户端随机一个随机数作为客户端的非对称加密的公钥，利用服务器的公钥对随机数加密，利用hash算法对摘要进行hash计算，并对摘要进行对称加密。加密后的随机密钥和摘要还有摘要的hash值一并发送给服务器。
- 服务器利用私钥揭秘出随机数，得到对称加密的密钥，利用加密的密钥解密出摘要的hash，如果hash值是一致的（因为自己也是用的同一套hash算法,),以后都使用这个对称加密的密钥进行加密。

总结：非对称加密用于在握手过程中加密生成的密码，对称加密用于加密真正传输的数据进行加密。hash算法用于验证数据的完整性。

**对称/非对称加密的优缺点**

对称加密的优点就是计算速度快，但是因为知道了公钥就一定能够揭秘出数据，所以在传递公钥的时候如果被窃听，那么之后的数据都是不安全的。

对称加密公钥加密的只能私钥解开，私钥加密的只能公钥解开。就算传输公钥被窃听，别人也破哦解不了数据。缺点就是运算速度慢。

所以HTTPS采用非对称加密算法加密公钥，再使用对称加密加密传输的内容。

**网站时如何从http自动跳转到HTTPS的**

浏览器默认填充HTTP，网站采用301或者302跳转到HTTPS，这个过程使用了HTTP，还是会受到劫持。

可以使用HSTS优化。使用户浏览器在访问站点的时候强制使用HTTPS。

## Session和Cookie的区别

因为HTTP数无状态的，因此我们每次访问有登录需求的时候，都要不厌其烦的输入账号密码，然而实际上却没有出现这样的情况，这是因为引入了Cookie 和Session使HTTP具备了状态。



**Cookie**：是服务器发给客户端的特殊信息，以文本的形式存在客户端，客户端每次向服务器发送请求的时候，都会带上这些信息。也就是说当用户使用浏览器访问支持Cookie的网站的时候，用户会提供个人信息，并且提交至服务器，紧接着服务器宰相客户端回传超文本的同时也会发回这些个人信息，这些信息并不是存在HTTP Response Body，而是在HTTP Response Head。当浏览器接收到这样的信息的时候，浏览器会将这些信息存放在统一的位置，之后，再向服务端发送需要个人信息的时候，会将这些信息携带至请求头中，服务器接收到再收到带有Cookie的信息，会解析Cookie然后做其他操作作出响应。

**Session**:是服务器端的机制，服务器使用一种类似散列表的结构来保存信息，当程序需要为某个客户端请求创建一个Session的时候，服务器首先检查这个客户端的请求里是否已经包含了一个Session标识,也就是Session ID,如果包含了Session ID,则说明以前已经为这个客户端创建了Session,服务器就按照Session 吧Session检索出来使用，如果检索没有，就新建一个。如果请求没有Session ID,则为此客户端创建一个Session,并生成一个于此相关的Session ID,这是一个不会重复也没有 规律的字符串， 这个Session ID会在响应中回发给客户端并保存。

**Session的实现方式**：

使用Cookie实现，服务器回发一个JSESSIONID给客户端，客户端时候到保存下来请求的时候在带上。

使用URL回写实现：URL是指服务器在发送给浏览器页面的所有链接中， 都携带JSESSIONID 的参数，这样客户端后面的连接都携带上这个。

**区别**

一个在客户端，一个在服务端。

Cookie不安全，别人可以分析存在本地的Cookie.

如果考虑减轻服务器负担，应当使用Cookie



## 从输入 URL 到展现页面的全过程

1. 浏览器查询 DNS，获取域名对应的IP地址:具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；

2. 浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；

3. TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求；

4. 服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；

5. 浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；

6. 浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。

   ## HTTP请求有哪些常见的状态码

1. 2xx状态码：操作成功。200 OK
2. 3xx状态码：重定向。301 永久重定向；302暂时重定向
3. 4xx状态码：客户端错误。400 Bad Request；401 Unauthorized；403 Forbidden；404 Not Found；
4. 5xx状态码：服务端错误。500服务器内部错误；501服务不可用

**小记**

在短网址系统里面

永久重定向 301 和临时重定向 302。

如果使用 301 的话，搜索引擎会直接展示原始网址，那么 TinyURL 就无法收集用户的 User Agent 等信息。这些信息可以用来做一些大数据分析，从而为 TinyURL 带来收益，所以需要使用 302 重定向。

## TCP 怎么保证可靠传输？？

- **检验和**

TCP校验和是一个端到端的校验和，由发送端计算，然后由接收端验证。其目的是为了发现TCP首部和数据在发送端到接收端之间发生的任何改动。如果接收方检测到校验和有差错，则TCP段会被直接丢弃。

把伪首部、TCP报头、TCP数据分为16位的字，如果总长度为奇数个字节，则在最后增添一个位都为0的字节。       把TCP报头中的校验和字段置为0。

其次，用反码相加法累加所有的16位字。最后，对计算结果取反，作为TCP的校验和。

- **序列号/确认应答机制**

只要发送端有一个包传输，接收端没有回应确认包（ACK包），都会重发。或者接收端的应答包，发送端没有收到也会重发数据。这就可以保证数据的完整性。

- **超时重传**

超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。**那么我们该如何确认这个时间值呢？**

一来一回的时间加上网络抖动的值。

- **最大消息长度**

在建立TCP连接的时候，双方约定一个最大的长度（MSS）作为发送的单位，重传的时候也是以这个单位来进行重传。理想的情况下是该长度的数据刚好不被网络层分块。

- **滑动窗口控制**

超时重传的机制存在效率低下的问题，发送一个包到发送下一个包要经过一段时间才可以。

窗口的大小就是在无需等待确认包的情况下，发送端还能发送的最大数据量。这个机制的实现就是使用了大量的缓冲区，通过对多个段进行确认应答的功能。通过下一次的确认包可以判断接收端是否已经接收到了数据，如果已经接收了就从缓冲区里面删除数据。

接收端在没有收到自己所期望的序列号数据之前，会对之前的数据进行重复确认。发送端在收到某个应答包之后，又连续3次收到同样的应答包，则数据已经丢失了，需要重发。

- **拥塞控制**

窗口控制解决了 两台主机之间因传送速率而可能引起的丢包问题，在一方面保证了TCP数据传送的可靠性。然而如果网络非常拥堵，此时再发送数据就会加重网络负担，那么发送的数据段很可能超过了最大生存时间也没有到达接收方，就会产生丢包问题。为此TCP引入慢启动机制，先发出少量数据，就像探路一样，先摸清当前的网络拥堵状态后，再决定按照多大的速度传送数据

## 简述 HTTP 1.0，1.1，2.0 的主要区别

## RestFul 是什么？RestFul 请求的 URL 有什么特点？

完全承认Http是用于标识资源。restFul URL是面向资源的，可以唯一标识和定位资源。 对于该URL标识的资源做何种操作是由Http方法决定的。 rest请求方法有4种，包括get,post,put,delete.分别对应获取资源，添加资源，更新资源及删除资源.

特点：

- 1.URL中不可出现动词
- 2.URL能够唯一地标识单个或一类资源
- 3.通过Http动词去操作URL标识的资源(get(获取),pst(添加),put(更新),delete(删除))



基于资源型的RESTFul API 接口粒度和返回结果过于的“粗”，它通常返回的都是完整的数据模型，这对于客户端非常不友好。但开放API之所以开放，就是因为它不知道你到底需要什么返回结果，既然不知道，那么我干脆都返回给你。这样的好处是通用，但客户端不好处理。你只需要一个字段，服务器啪的丢给你十几个，作为客户端开发者你怎么想？

内部开发由于需求非常明确，通常来说服务器是不应该简单粗暴的直接甩资源实体给客户端的。那RESTFul API就不能接入到内部开发吗？当然不是，我们需要灵活一些借鉴RESTFul中的优点，来设计我们的内部API。