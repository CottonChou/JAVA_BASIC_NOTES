## YoungGC 和FullGC的触发条件

### 区别

YoungGC发生在新生代，新生代的对象都是朝生夕灭的，发生频率频繁，回收速度快。

FullGC发生在老年代，发生了FullGC之前必然发生了YoungGC.

### YoungGC的过程

首先要明白新生代的内存划分结构。新生代的内存按照8：1：1的比例划分，8份伊甸园，2份幸存区，幸存区每次只使用一块。

在初始阶段，（一般情况下）对象都被分配在伊甸园区，当伊甸园区满了的时候，触发一个YGC,存活的对象将会被放置在其中一块幸存区0，并且年龄加1.

后续发生YGC，会将存活的对象复制到另外一块幸存区。这个思想的前身就是标记复制算法。

### 什么样的对象会进入到老年代

**15岁**

每次在ygc存活下来的对象，年龄会＋1，根据虚拟机的默认配置，满15岁的对象会晋升到老年代。

**大对象**

虚拟机可以设置一个参数，指定多大的对象分配不在新生代，直接存放在老年代。这样避免在新生代的垃圾回收频繁复制大对象。

**动态年龄**

如果幸存区的相同年龄的对象大小大于幸存区一半的空间，年龄大于等于这个阈值的对象进入老年代。

## FGC的触发条件

调用System.gc()

在每次YGC之前会检查老年代的空间大小。当老年代剩余空间小于新生代对象总大小或者小于历次晋升老年代的平均大小，FGC。