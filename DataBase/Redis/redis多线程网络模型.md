## Redis多线程网络模型

### redis为什么快？

一个redis实例的QPS在8W以上，如果利用了pipeline，可以达到100W+。

纯内存I/O，内存比磁盘块，Redis除了持久化交互到了磁盘，纯内存的操作速度比起磁盘就是快。

- I/O多路复用，不管是之前的版本还是Redis6之后，redis一直采用的I/O多路复用假非阻塞的形式来处理网络IO
- 单线程模型，单线程避免了频繁的上下文切换寄存器置换，堆栈重置等开销。
- 单线程不需要加锁，redis作为一个数据库如果支持多线程的话，必然要用到各种同步机制，那么实现起来就麻烦。
- 对于一个内存数据库来说，CPU一般不是性能的瓶颈，大多数的请求不是CPU密集型，而是IO密集型，对于Redis来说，性能瓶颈在于网络IO。也就是客户端和服务端之间的网络传输延迟，因此redis之前采用了单线程的IO多路复用来实现网络模型。

实则在redis4的时候，redis引入了多线程异步处理一些任务。主要是针对一些比较耗时的命令。比如删除一个大key，里面有很多值，最开始作者想的是渐进式的删除，后来觉得还是多线程写起来好理解。

在redis6版本，在网络IO模型中实现了多线程。

### Redis6 之前的网络模型

单Reactor模型：利用epoll/select/kqueue等多路复用技术，在单线程的事件循环中不断处理客户端的请求。最后回写响应数据到客户端。

大致流程是这样的。

- 服务器启动，开启主线程事件循环 ，这个事件循环主要做的事情就是把客户端缓冲区的数据响应给客户端，执行 AOF操作。注册连接应答处理器，等待连接的到来。
- 客户端和服务器简历连接。
- 连接应答处理器被调用，主线程初始化一个client实例绑定这个客户端，设置相关信息，比如套接字连接，数据库指针，读入缓冲区，写出缓冲区（16KB），写出链表。
- 读取客户端发送过来的命令，存入读入缓冲区。
- 解析发过来的命令，根据请求的命令类型找到对应命令处理器去执行，最后将执行结果写入到客户端的写出缓冲区，太多了写不下就写到写出链表。
- 主线程循环，此时缓冲区有数据了，将缓冲区的数据写到客户端。

## Redis6 多线程网络模型

提升redis的性能有两种方式。

优化网络IO（有多线程和零拷贝两种方式）

提高内存读写速度。（加钱）

Redis的多线程网络模型不是朝着预期的单Reactor变多Reactor。传统的多Reactor模型有一个mainReactor分发任务，subReactor负责网络读-数据解析-执行命令-网络写整套流程，而Redis I/O线程任务仅仅是通过socket读取客户端对请求命令解析，却并不执行。所有的客户端命令最后还是回到主线程区执行，而且每次主线程都必须等到所有io线程处理完了之后(这里难道没有工作窃取算法吗)才能继续执行其他逻辑。

redis之所以如此实现是因为以前是单线程，底层数据结构全部没有同步机制。以前的命令都是在单线程客户端轮询里面执行的，这样是为了兼容以前的逻辑。如果要彻底利用多核性能，就要重写所有的内置数据结构。工作量大，以后的版本应该会改进？