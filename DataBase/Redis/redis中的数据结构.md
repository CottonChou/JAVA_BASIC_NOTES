> redis中有六种比较重要的数据结构，SDS，链表，字典，跳跃表，整数集合，压缩列表。redis的对象主要是靠这六种数据结构实现的。

## 数据结构

### 简单动态字符串（SDS）

Redis没有使用C语言中的传统字符串，而时自己构建了一种SDS的数据结构，在redis中包含字符串的键值对底层都是用SDS实现的。除此之外，AOF缓冲区，客户端状态的输入缓冲区都是由SDS实现的。

```c
struct sdshdr{
    //已经使用的字节数
    int len
    //剩余的字节数
    int free
    //字节数组，用来保存字符串
    char buf[]
}
```

带有未使用空间的SDS示例：

```json
sdshdr
free:5
len:5
buf ->['r','e','d','i','s','\0','','','','','','']
```

- 和c语言比起来，c的字符串不会记录自己的长度，去过想取c语言的字符串的长度要把整个字符串遍历一百年，时间复杂度是O(N)，redis直接记录了，时间复杂度是O1.（记录长度这不是基本操作吗，唉）

- C字符串不会记录自身的长度，所以在执行strcat等函数的时候可能会造成缓冲区溢出的问题，而在SDS中，进行此类操作会先检测是否出现缓冲区溢出的情况，然后再执行操作。

- C字符串不会记录自身的长度，所以再字符串需要增长或者缩短时，需要重新分配内存，这期间又缓冲区溢出或者内存泄露的问题。在sds中，采用了空间预分配和惰性空间两种优化策略。

  ​		空间预分配

  SDS需要扩展的时候，不仅会为SDS分配需要的空间，还会分配额外未使用的空间，减少连续执行字符串增长操作的需要的内存分配次数。

  惰性空间释放

  SDS需要缩短的时候，不会重新分配内存来释放多余空间，而时使用free字段将这些字节的数量记录下来，便于将来使用。同时也提供了释放空间的api，在需要的时候手动释放。

- 二进制安全

  二进制安全，C的字符串除了末尾之外，不能包含空字符，所以保存二进制数据的话，会误以为空字符是字符串结尾。而SDS是通过len属性来判断是否结束，不受空字符的影响。

- 兼容部分C字符串操作。

### 链表

由于C语言没有提供链表这样的数据结构，redis自己实现了双向链表。

链表在redis中的应用非常广泛，列表键的底层实现之一就是链表，当一个列表键中包含了比较多的元素，又或者列表中包含的都是比较常得字符串时，Redis就会使用链表作为列表键的底层实现。

Redis链表特性：

- 双端链表：双链表
- 无环：链表头节点的prev和尾巴节点的next指向null
- 带表头和表尾指针
- 带长度计数器
- 多态

链表应用广泛，列表键，发布和订阅，慢查询，监视器等等。服务器本身就使用链表来保存连接的客户端信息，也使用链表来构建客户端输出缓冲区。

### 字典

redis的数据库就是使用字段作为底层实现，字典的底层作为底层实现。

```c
//哈希表结构
typdef struct dictht{
    //哈希表数组
    dicEntry **table
    //哈希表的大小
    usigned long size;
    //掩码 计算索引值
    unsigned long sizemask
    //已使用的键值对树
     unsigned long used;
}
```

**字典结构**

```c
typedef strunt dict{
    dictype *type;
    void *private;
    dictht ht[2];
    //rehash索引，rehash不在进行的是皇后，为-1
    int rehashidx;
}
```

一般情况下，字典使用ht[0]哈希表，ht[1]只会在怼ht[0]rehash时使用。

rehashidx记录了rehash目前的进度，如果没有进行rehash，则为-1.

**发生扩容的条件**

服务器没有执行`bgsave`或者`bgrewriteaof`命令，并且负载因子大于等于1

服务器正在执行`bgsave`或者`bgrewriteaof`，并且负载因子大于等于5.

因为bgsave的时候，此时有一个子进程在进行cow。此时故意提高负载因子避免在cow期间存在hash表扩容操作，避免不必要的内存写入操作。

`负载因子 = 键值对的数量/size`

**发生收缩的条件**

负载因子小于0.1

扩容和收缩都通过rehash来完成。

**rehash步骤**

因为redis使用字典作为数据库的实现，所以rehash的过程不是一次性完成的，这样避免在迁移期间数据量太大给服务器的压力太大。`redis`采用的是渐进式hash主键的将ht[0]的数据慢慢的hash到ht[1]上。

- 为ht[1]分配空间(两倍扩容)，字典同时持有ht[0],ht[1]两个哈希表。
- 在字典中维持以合索引计数器变量rehashidx,将他的值设置为0，表示rehash开始。
- 在rehash期间，每次对字典的添加，删除，查找操作，程序都会额外的将ht[0]的元素索引上的所有键值对全部迁移到ht[1]上，本次工作完成，rehashidx+ 1。
- 随着这样的操作进行，最终总是会把所有的键值对rehash到ht[1]上，这个时候rehashidx设置成-1，rehash完成。
- 释放ht[0]，将ht[1]置为ht[0],在ht[1]上创建一个空链表。
- rehash的过程中，查询先查ht[0],没有查到再去查询ht[1]。插入一律保存在ht[1]

### 跳跃表

> 待续



跳跃表是一种平均时间复杂度OlogN，最坏时间复杂度On,但是在`redis`的底层仅仅是有序集合和集群节点内部用到了跳表。

### **跳跃表的实现**

**跳跃表节点结构**

```c
typedef struct zskiplistNode{
    //层
    struct zskiplistLevel{
        //前进指针
        struct zskiplistNode *forward;
        //跨度
        usinged int span;
    }level[];
    //后退指针
    struct zskiplistNode *backword;
    //分数
    double score;
    //成员对象
    robj *obj;
}zskiplistNode;
```

**跳跃表结构**

```c
typedef struct zskiplist{
    struct zskiplistNode *header,*tail;
    usigned long length;
    //次数最大的节点的层数 不就是最大层数？
    int level;
}zsliplist
```

- 层

1. 每次创建一个新的节点都会根据幂次定律随机生成一个介于1到32之间的值作为level的大小，这个值就是层的高度。

- 跨度

1. 记录的是两个节点之间的距离。
2. 跨度不是用来做遍历操作得，遍历只需要使用前进指针就可以完成。
3. 跨度用来计算排位的，在查找某个节点的过程中，将沿途的访问过的跨度累加起来，就是目标节点的排位。

- 后退指针

1. 用于从表尾向表头访问节点，每次只能后退一个节点。

- 分值和成员

1. 分值是double类型，用来排序。先按照分值排序，再按照成员排序。
2. 成员是一个指针，用来指向字符串对象。

**查找**

在跳跃表中查找一个元素X的步骤：

1.从最上层的链的开头开始假设当前位置为p，他向右指向的节点为q,且q的值为y.

2.将y与x作比较：

- 如果x == y,输出查询成功，输出相关信息。
- 如果x大于y,从p向右移动到q的位置；
- 如果x小于y,从p向下移动一格，如果当前位置在最底层的链s0中，且还要往下移动的话，就查询失败。

## 为什么要同时使用跳表和字典实现有序集合？

虽然只用一种数据结构也可以实现有序集合，如果只是使用字典实现，虽然查找时间复杂度是O(1)，但是字典是无序的，执行范围查找的时候，就需要对所有的元素进行排序排序时间复杂度至少OlogN才行。

同理，跳跃表在顺序访问和范围访问比字典好，但是根据查找某一个具体的值时间复杂度又是O(N)了。