## 为什么是B+树

索引的作用就是为了做数据的快速检索，选择不同的数据结构有不同的性能，数据库里面存储了大量的数据，就比如一本字典一样，如果没有目录，靠暴力遍历想要找到一个内容十分麻烦。

**hash**

如果为了实现快速查找，完全可以使用hash，但是hash只适合用于等值查询，一批有序的数据存进hash表，经过hash运算，存放的次序是无序的，hash不能完成按序查找和按照范围查询。如果想要用hash表实现一个范围查找，必须要把数据全部加载进内存暴力过一遍。

**二叉搜索树**

二叉搜索树的中序遍历可以达到有序的遍历呀，时间复杂度是logN,如果想要大于某个值的数据，只需要把他右边的叶子节点树父亲节点那一块就可以了。普通的二叉搜索树在极端的情况下，我觉得在我们实际应用场景中，主键陆续递增的插入下，二叉搜索树很容易严重倾斜，退化成链表。检索数据的时间复杂度就是O(n),肯定不能作为索引。

**AVL树和红黑树**

AVL树和红黑树都具有自动旋转和调整的能力，究其原因就是数据都是存在磁盘上面的，如果使用二叉树结构，不管是AVL树还是红黑树，一个节点只存了一个值，一次磁盘IO读取一个节点，树越深IO次数越多，对于磁盘数据结构来说，二叉树都是不适合的。



B树和B＋树都是多叉树，不同的是B树节点里面存的是数据，B+树非叶子节点存储的是地址，所以B树一个节点存的数据比B+树少，B＋树的叶子节点存有了全部的数据，并用双链表链接起来，但B树不是。同样的数据量下，B+树更矮，在做范围查找，排序的时候比B树效率更高。

## 最左匹配原则

最左匹配原则一般发生在字符模糊查询和联合索引里面。

**联合索引**

建立联合索引可以减少索引树，减轻数据库每次插入时维护索引树的压力。

如果建立一个 a，b，c三个字段的联合索引，这样建立索引的含义就是先按照a列进行排序，a列相同再按照b列进行排序，b列相同，再按照c列进行排序。

**等值查询**

举个例子：

```sql
select * from test where a = x and b = y and c = z
```

由于联合索引排序的顺序，所以符合a=x,b=y,c=z的数据一定是相邻的，只需要找到第一条a=x and b = y and c = z的记录，沿着叶子节点一致往后扫描，直到某条记录不符合位置。

如果是全等值查询且有可能会使用到联合索引，优化器会自动帮我们优化。

例如

```sql
select * from test where   c = z and a = x and b = y
```

优化器是可以优化成abc的顺序。

**范围查询**

而如果查询语句里面有范围查询，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配

**如果有分组和排序**

order by 后面的顺序也要符合索引的顺序，而且不能混用 asc desc（8.0又可以了）

**模糊查询**

满足%结尾且符合索引顺序的模糊查询，但仅仅只满足一列。

## 数据库的事务隔离级别有哪些？各有哪些优缺点？

**读未提交**

可能发生脏读，不可重复读，幻读。

**读已提交**

不会发生脏读，不可重复读会发生幻读。

**可重复读**

可能发生幻读

**可串行化**

不会发生

隔离级别越强，性能越差。MySQL默认的隔离级别是可重复读。

## MVCC

对于InnoDB的存储引擎来说，聚簇索引都会包含两个必要的隐藏列。

**trx_id**：一个事务每次对某条聚簇索引记录进行改动时，都会把该事务的事务id赋值给trx_id。

**roll_pointer**：每次对某条聚簇索引进行改动的时，都会把旧的版本写入到undo日志中，这个隐藏列相当于一个指针，可以通过该记录找到修改前的信息。

每次对记录进行一次改动，都会记录一条日志，每条日志都会有一个roll_pointer属性，insert没有，通过这个属性将undo日志串成一个链表。版本链的头结点就是当前记录的最新值，这就是多版本并发控制。

对于读未提交的隔离级别，直接读取记录的最新版本就好了。

对于串行化读，执行严格的加锁。

对于读已提交和可重复读。

需要利用到这几个属性帮忙。

**m_ids**：再生成readView的时候，当前系统中活跃的事务ID列表。

**min_trx_id**：生成ReadView的时候，当前系统中活跃的读写事务最小的事务id.就是m_ids的最小值。

**max_trx_id**：生成ReadView的时候，系统应该分配给下一个事务的事务ID.

**create_trx_id**:生成ReadView的ID

- 如果被访问版本的事务ID与readView中的创建ID相同，以为着当前事务在访问自己修改过的记录，所以该版本可以被当前事务访问。

- 如果被访问版本的事务ID属性值小于ReadView的事务最小值，表明生成该版本的事务在当前事务之前，已经被提交。可以被访问。

- 如果被访问版本的事务ID属性值大于或者等于ReadView的事务最大值，表明生成该版本的事务在生成ReadView之后，不能被访问。
- 如果被访问的版本事务ID属性值在ReadView的事务minID和maxId之间，则需要判断此版本的事务ID是否在活跃事务ID列表中，如果在，说明创建ReadView的时候，这个事务还是活跃的，不能被访问。如果不在，说明在生成ReadView的时候，已经被提交，可以访问。

读已提交和可重复读的区别就是生成ReadView的时机不同。

读已提交在每次读取数据的时候都会生成一个ReadView。

可重复读是在第一次读取数据的时候生成一个ReadView。

> 特殊情况，注意当前读。就是自己更新的数据自己是可以看见的，也是满足上面的tips。

