# Undo Log

> 为了保证事务的原子性，就需要保证事务中的操作要么全部完成，要么什么都不做，在程序员自己手动回滚或者服务器发生错误时保证事务的原子性，恢复到以前的状态，MySQL利用Undo Log记录了回滚一个操作必要的内容。

- 正常的数据存放在数据页中，而Undo Log的数据存放在日志数据页中，日志数据页在系统表空间的第五号页面的回滚段申请，统一管理。MySQL最多有128个回滚段，一个回滚段有1024个槽位(slot),一个槽位如果没有被分配那就是空的，如果被分配了，那就是被一个事务给申请占用了，槽位里面存放的是回滚页面链表的头节点的指针。也就是说MySQL最多同时支持128*1024个并发事务的执行。

- 在服务器奔溃后来想恢复的时候，首先是根据redo日志将各个页面的数据恢复到奔溃之前的状态，保证了事务的持久性。其次是如果有部分没有提交的事务的redo日志也刷盘了，那么这部分事务可能也会被恢复了，那么此时需要利用到undo日志来回滚这部分事务保证事务的原子性。
- 因为undo日志页面都是在系统表空间的第5号页面申请的，所以回滚时此时到系统表空间5号页面寻找回滚段，在每一个回滚段中寻找被占用的槽，从槽中的回滚页面链表的头节点的信息中判断事务的状态，如果事务是活跃的，说明此事务是一个没有被提交的事务，那么根据Undo日志记录的信息将页面做的修改全部回滚，从而保证了原子性。

## Undo Log的分类

- 对于查询操作来说，并不会修改任何的用户记录，所以查询操作没有Undo Log,**删除和更新都属于Update Undo Log**,Insert操作是单独的，因为插入操作的回滚比较简单，只需要将插入的数据的主键记录下来，回滚时删除就好了。

- 一个事务的执行过程中可能会产生很多的undo日志，可能一个undo数据页存放不下，需要新开页面，所以可能会有多个数据页面存放一个事务的undo日志，他们之前以链表的形式组织在一起。

- 一个事务的执行过程中会混合多种操作，插入，删除，更新都可能同时具备。不同的操作进行分类记录，并且对于对于普通表和临时表的记录也是分开的。所以最多有四种链表日志，但是分配的时候是按需分配，不是一开始就整四个链表，刚开启事务的时候，是一个链表也没有的。

  **一个事务的Undo日志组织形式**

  ```json
  普通表的Undo日志： insertUndo链表
                   updateUndo链表
  临时表的Undo日志： insertUndo链表
                   updateUndo链表
  ```

### Insert操作

当往某个表插入一条数据的时候，实际上是往聚簇索引和所有的二级索引都插入一条记录，不过记录Undo日志却只记录在聚簇索引之上，通过聚簇索引行的`roll_pointer`指针找到Undo Log，回滚Insert操作的时候，只需要知道主键信息，根据主键信息删除就好了。**更新和删除的Undo Log都是记录在聚簇索引之上的。**

所以插入操作的Undo Log需要记录的信息：哪张表，操作类型，主键信息，其他辅助信息。

### Delete操作

- 在每个数据页里面存放的是多行的数据记录，数据记录之间使用next_record指针连接组成单链表。
- 数据页还维护了数据页的page_free空闲属性，page_free指向被真正删除的数据记录组成的垃圾链表的头节点。
- 在事务执行过程中执行删除操作，仅仅也是逻辑删除，将行记录逻辑删除，而不加入到垃圾链表，在事务提交之后，也会有专门的线程来维护页面，将记录删除，加入到垃圾链表中。在逻辑删除前，会将该数据行的旧的事务ID和roll_pointer属性都记录到undo Log里面。尽管Undo Log是按照操作类型分类再组织成链表形式，但是逻辑上也可以通过roll_pointer指针将同一个数据行的不同操作的Undo  Log串联成版本链。

所以删除操作的Undo Log需要记录的信息 ： 哪张表，回滚指针，操作类型，主键和其他列删除之前的数据，其他辅助信息。 

### Update操作

>  update操作分为更新主键和不更新主键两种情况。

#### 不更新主键

> 不更新主键又可以细分为被更新的列空间大小是否会发生变化

**就地更新**

如果更新后的列和更新前的列所占的存储空间是一样大的，那么可以直接在原纪录上进行修改，就是就地更新。

**先删除旧记录再插入新记录**

在不更新主键的情况下，如果更新列前后的存储空间不一致，首先需要将这个旧的记录从聚簇索引上删除，这里的删除是真的删除，不是逻辑删除，直接加入到垃圾链表了。我想可能是因为主键还在不影响MVCC吧。如果更新后的记录小于之前的旧纪录的空间，那么可以重用他的空间，如果大于那么需要在数据页里面申请新的空间来记录，如果页面剩余的空间都不够用了，那么就需要页分裂操作，再插入记录了。

#### 更新主键

因为数据在页内都是根据主键大小顺序以单链表的形式组织在一起，如果更新了主键，新的记录的位置势必会改变，此时采用的也是先删除后插入的操作，不同于不更新主键的方式，这里的先删除是逻辑删除，因为考虑到了MVCC。可能其他的事务还在访问这个数据。再添加新的记录，需要根据新的主键值寻找合适的地方插入。可能在同一个页面，可能不在。

所以Update Undo Log需要记录的信息：哪张表，回滚指针，操作类型，主键和其他列之前的数据，有多少行被更新了，自己所占用的空间大小，其他辅助信息。