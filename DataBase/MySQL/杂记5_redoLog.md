# redo Log

> InnoDB是按照页为单位来管理存储空间，访问页面之前先把磁盘的页加载到内存的BufferPool，之后才可以访问，对页的修改也是基于BufferPool,修改过的页称之为脏页，如果脏页没有及时的刷到磁盘，系统突然崩溃，导致内存数据失效，那么对数据库的操作也失效了，这就违背了持久性和一致性。
>
> MySQL采用redo Log记录对哪些数据页进行了修改，在事务提交时，redo Log刷新到磁盘，在奔溃重启时，利用redo Log来重新更新数据页。

相比于在事务提交时将所有修改过的内存中的页面刷新到磁盘，使用 redo Log具有以下好处。

- redo Log占用空间少，仅仅存储表空间ID，页号，偏移量，以及需要更新的值。而如果是仅仅修改了一条数据，就需要刷新一个脏页，太过于浪费。
- redo Log 是顺序写入磁盘的，在执行事务的过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照产生的顺序写入磁盘，使用的是顺序IO，而如果是采用每次刷新脏页的方法，一条语句设计到修改的页面可能并不相邻，就不一定是顺序IO，而是随机IO。

## Mini-Transaction

- 一个事务的执行可能不止一条SQL语句，一个SQL语句的执行修改的数据页可能不止一个。对某一个B+树修改一条记录可能设计到多个多个页面的修改，如果发生了页分裂，那么需要修改多个页面，又设计到维护内叶子节点(目录),MySQL认为向某个索引的B+树插入一条记录必须是原子性的，因为在悲观插入时会涉及到多个页面的改动，如果不能够正确的执行这些改动，会形成一颗不正确的B+树。
- MySQL讲这种对底层页面的操作定义为一个Mini-Transaction(Mini事务，MTR)。

## redo Log的写入和刷盘时机

**写入过程**

不同于一般的数据页管理，redo Log的单位是512字节，一般称为redo Log 块。在redo Log写入时也用到了缓冲区，redo Log写入时不是直接就写到了redo log Buffer，而是讲每个MTR的日志暂存到一个地方，一个MTR的日志为一组日志，结束后插入特殊结尾标记，再将一组日志写入到redo Log Buffer.

**刷盘时机**

- log buffer空间不足，使用率大于百分之50的时候。
- 事务提交的时候
- 等待后台线程去刷新
- 正常关闭服务器
- 做checkpoint

### Log Sequence Number

- **LSN来记录来记录总共写入的redo日志总量**，这是包括了写到了log buffer还没写入到磁盘的redo Log。还可以根据大小来比较页的版本。LSN不仅仅存在于redo Log里面，还存在于每个页中，在页中，表示该页最后刷新时LSN的大小。假设页的LSN是1W，redo Log的LSN是1W3，那么说明这页数据需要恢复到数据库。
- **flush_to_disk_lsn**表示刷新到磁盘日志文件的LSN。
- **checkpoint**表示刷新到磁盘脏页的最新LSN。

**用一句话来描述三者之间的联系：**

redo日志一直在往log buffer缓冲区里面写入，需要等待一定的时机去刷盘，刷盘了多少需要用一个指针记录，这就是flush_to_disk_lsn，而脏页也是是重要刷盘的，对于已经刷盘的脏页，也要记录下来他对应的LSN。

有两点好处：

第一，在尝试恢复的时候，对于已经刷盘的脏页就不用理会了。

第二，对于已经刷盘的脏页的redo日志，理论上来说也不需要了，这是可以重新利用的，用来记录新的redo日志。

### 恢复

只需要找到checkpoint开始的地方，开始执行redo log便可以正确的恢复数据了。

**MySQL对于恢复的加速的优化**

根据redo log的表空间ID和页号属性计算出hash值，讲同一个表空间的同一页放在同一个hash槽，这样在恢复数据的时候可以一次性的修复一个页面，加快恢复的速度。

redo log是物理日志，服务器重启的时候首先是检查redo log,redo log的恢复速度比binlog快得多，bin log是逻辑日志。比如对于一个页面的修改redo log是这样记录的。

```sql
page(2,3) offset 32 value 1,2
```

