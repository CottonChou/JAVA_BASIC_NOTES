# 锁

> 在并发事务读写的情况下，会发生脏读，不可重复读，幻读的现象。
>
> MySQL解决以上现象主要有两种办法：MVCC和加锁。MVCC读写并不冲突，相比于加锁使读写排队执行，性能更高。

- **MVCC**

  MVCC通过`ReadView`的机制来判断和保证普通的查询语句只能读取到生成`ReadView`之前已提交的事务的更改，看不到生成`ReadView`之前未提交或者之后的事务更改。写操作永远是针对最新版本的记录，读记录的历史版和写最新的记录二者并不冲突。在RR隔离级别下，事务期间始终使用的都是同一个`ReadView`（事务启动时生成），也就避免了脏读，不可重复读和部分的幻读现象。

- **加锁**

  如果一些业务场景不允许读取记录的旧版本的值，而是每次读取都需要最新值，那么只能通过加锁的方式来控制，使读写排队执行。

## `InnoDB`里面的行锁和表锁

### 表锁

- **表级别的S,X锁**

  在对某个表执行`drop table`,`alter table`之类的DDL语句时,会阻塞DML语句。反之亦然。这种看起来锁表的行为不是通过表锁实现的，而是对**元数据**加锁实现的。

  使用`InnoDB`的表锁一般只在数据奔溃恢复时派上用场。需要手动获取。

  ```sql
  LOCK TABLE T READ;（S锁）
  LOCK TABLE T WRITE;（X锁）
  ```

- **表级别的IS,IX锁（意向锁）**

  在对表记录上S,X锁之前，需要在表级别上加一个对应的IS,IX锁。表级别的IS,IX锁并无多大用处，仅仅是为了在对表加锁之前，快速判断表中的记录是否被上锁罢了。避免用全表遍历的方式来查看表中是否有上锁的记录。

### 行锁

- **Record Lock**

  仅仅在一条记录上加锁，官方变量名字叫`lOCK_REC_NO_GAP`,record Lock也有S和X之分，显然事务之间SS不互斥，SX互斥，XX互斥。

- **Gap Lock**

  如果采用加锁方案来决绝幻读的现象，难点在于幻读发生之前，记录并不存在，那么`Record Lock`也就无用武之地。`Gap Lock` 为了解决幻读问题而诞生，`Gap Lock` 在记录**之前的间隙**加锁，避免别的数据在记录之前插入数据。`Gap Lock` 仅仅是为了防止插入幻影记录，与其他的锁不互斥。意思是加了`Gap Lock`的地方不影响前后继续追加`Record Lock`，不影响继续追加`Gap Lock`。

  因为页内最小值最大值哑巴节点的存在，所以对最大值哑巴节点加`Gap Lock`，就能防止在最后一条普通记录之后插入幻影记录。

- **Next-Key Lock**

  `Next-Key Lock` 本质上就是`Record Lock` 和`Gap Lock`的结合体，他可以**同时对行记录和行之前的间隙加锁**。既保护了行记录，又能阻止别的事务将新的记录插入到记录前面的间隙中。

### 语句加锁分析

> 对于普通的select语句，在小于等于RR隔离级别以下都是不会加锁的，加锁的语句只会发生在锁定读的语句和更新语句中。

由于脑容量优先，我只重点关注了RR隔离级别的加锁分析。

- 在范围查找中，MySQL生成扫描区间，根据扫描区间去扫描索引树上的叶子节点，**对索引树的加锁从第一条满足扫描区间的记录开始加`Next-Key`锁，到最后一个不满足扫描区间的记录结束。左闭右闭区间**。**扫描区间范围内不论是否满足最终搜索条件都会加锁，在事务提交之前不会释放锁。且如果涉及回表操作，对回表设计到的聚簇索引记录添加`Record Lock`。**
- 在精确匹配查找中，如果有匹配到的结果，不论是一行还是多行，**会为匹配到的行添加Next-Key锁**，如果涉及回表操作，**对回表查询的聚簇索引记录添加Record-Lock**。如果无任何匹配记录，会对搜索条件的下一个记录之前添加**Gap Lock。**

**例子**

```sql
create table hero(
    number int,
    name varchar(100),
    country varchar(100),
    primary key(number),
    index inx_name (name)
)
```

**聚簇索引记录**

| number  | 1     | 3       | 8     | 15    | 20    |
| ------- | ----- | ------- | ----- | ----- | ----- |
| name    | l刘备 | z诸葛亮 | c曹操 | x荀彧 | s孙权 |
| country | 蜀    | 蜀      | 魏    | 魏    | 吴    |

**二级索引记录**

| name   | c曹操 | l刘备 | s孙权 | x荀彧 | z诸葛亮 |
| ------ | ----- | ----- | ----- | ----- | ------- |
| number | 8     | 1     | 20    | 15    | 3       |

**执行语句**

```sql
select * from hero force index(idx_name) where name > 'c曹操' and name <= '荀彧' and country != '吴' lock in share mode
通过强制指定索引使用二级索引。
索引下推的条件是 name > 'c曹操' and name <= '荀彧'
```

1. 根据查询区间`name > 'c曹操' and name <= '荀彧' ` 在二级索引树上第一个符合扫描区间的是`l刘备`。
2. 为`name = 'l刘备`添加S型的**`Next-Key`锁**，本条记录满足索引下推条件的条件。
3. 由于扫描的是二级索引，所以需要回表操作，找到聚簇索引相应的记录，**为该聚簇索引记录添加`S型的Record锁。`**
4. 该记录满足边界条件。
5. server层判断该记录是否满足其他搜索条件，`coutry ！= '吴',符合`，将该记录发送给客户端，**但是，不释放任何锁。**
6. 获取下一条记录，到了孙权这里，孙权满足扫描区间，添加`Next-Key`，满足索引下推条件，回表查询，为聚簇索引相应记录添加`Record Lock`,**发现不满足搜索条件，不返回数据给客户端，但是，不释放锁。**
7. 获取下一条记录，荀彧，荀彧同刘备，略过不谈。
8. 获取下一条记录，到了诸葛亮这里，为二级索引树添加`Next-Key`，再判断本条记录不符合索引下推的条件，且不符合边界条件，所以不会再去寻找下一条记录了。查询结束。
9. 事务提交之后才释放锁。