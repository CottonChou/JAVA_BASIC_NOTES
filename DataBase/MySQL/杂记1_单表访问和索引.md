## InnoDB页

磁盘数据库，数据存放在磁盘的。每次处理数据需要从磁盘读取数据道内存，但不是一行数据一行数据读取，那样太慢，而是以页为单位来读取，页的单位默认是16kb，一次最少读取一页，如果是写操作和更新操作，一次最少更新一页。（是不是有写放大的问题?）

如何防止刷新页的途中断电的脏数据问题？

每一页的头部和尾部都有一个校验和部分，在刷新之前提前计算出校验和。如果只刷新了一般的页面，他的头尾的校验和是对不上的。（File header/File Trailer）

**页内数据的组织方式**

页内数据逻辑是按照以行为单位组织存放在数据业内，每一行都有一个next_record字段指向下一行，这类似与单链表。一页内有两个哑巴行，代表是页内的最小行和最大行。在一个数据页内，按照行的主键进行分组，每一组对应一个槽位存放在页目录里面。页内查找数据的方式就是先根据二分查找定位处于哪个槽，再根据槽提供的页内偏移量定位到行，通过行的next_record属性顺序遍历槽内数据。

页与页之间是按照双链表的形式进行组织的。

## 索引

索引分为聚簇索引和二级索引。

如果不按照索引为搜索条件在页内查找数据，那么无法利用主键或者索引行的有序性，就没办法使用二分查找定位数据页，定位数据行。

B+树索引本质上是一个非常大的多层级目录，除了最底层的叶子节点，其他层的非叶子节点都是对下层节点的索引目录。

mysql规定。一页之内最少容量两条记录，所以B+树是一个多叉树。

如果以索引列根据条件搜索，首先以二分法查找目录，通过目录过滤掉大部分不符合要求的数据页，最后定位到数据页，再根据二分查找定位到页内的槽，再遍历。

**聚簇索引和二级索引的不同**

1. 聚簇索引的叶子节点存储的是全部的数据，页内数据的行是完整的数据行。叶子节点按照主键值的顺序排序。
2. 聚簇索引的内叶子节点存储的是主键索引和页号。
3. 一个最简单的二级索引也是一个包含了主键值的联合索引。
4. 二级索引树的叶子节点存储的二级索引值和主键值，先按照二级索引值排序，再按照主键值排序。从这里来看，一个再简单的二级索引也是和主键组合在一起的联合索引。
5. 二级索引树的内叶子节点存储的是二级索引值和主键值和页号。之所以要存储主键值是依靠主键的唯一性来保证目录的唯一性。
6. 二级索引叶子节点存储的是不完整的数据行，这样减少了索引树的空间，但是这也导致了查询二级索引树需要回表操作。

**索引是有代价的**

1. 每建立一个索引都需要维护一个索引树。
2. 每修改一条数据都要维护所有的索引树。无论是叶子节点还是内叶子节点都是按照索引的大小顺序排序，增加删除操作可能会对节点的排序顺序造成影响，需要使用页分裂页回收之内的操作来维护节点的顺序。

**几个建立索引的原则**

1. 只为搜索，排序，分组的字段建立索引
2. 当列中不重复值的个数在总记录中占比很大时，才为这个列建立索引、
3. 索引列的类型尽量小。
4. 可以只为列前缀建立索引，减少索引占用的存储空间。（但是就不能使用这个索引用来排序了）
5. 尽量使用覆盖索引，避免回表。
6. 尽量的使用拥有递增属性的主键，避免新增记录要发生页分裂。

## 单表访问方法

- const (常数级别)

  通过主键或者唯一索引(行不能为null)的等值查询

- ref

  普通索引的等值查询，因为普通索引不能确定其唯一性，需要扫描到第一个不符合条件的记录位置。所以不是常数级别的复杂度。

- ref_or_null

  顾名思义，还会扫描会null的字段行。

- range

  对索引/主键列使用了范围查询.

- index

  index并不是使用到了索引过滤多余的数据。仅仅是指用到了索引树。

  比如：联合索引abc

  ```sql
  select a,b,c from test where b = 'x'
  ```

  首先，b不是联合索引最左边的列，不能使用最左匹配原则。无法满足ref,range.但是查询列表恰好只有索引的三个列，搜索条件也包含在内。也就是说可以通过遍历整个二级索引，对每一条记录做一个判断。这个过程不需要回表，二级索引树比聚簇索引树更小，所以相比于全表扫描和回表搜索成本降低。这种扫描全部索引的方式就是index。

- all

  全表
  
- intersection索引合并

  假设有一个查询可能会使用到两个索引，MYSQL可能会使用到索引合并。

  ```sql
  select * from test where a = 'x' and b = 'y'   (假设有a和 b两个单独的索引)
  ```

  同时扫描索引树a（a = 'x'）和索引树b(b = 'y')寻找满足条件的记录。

  从二者的结果中寻找**交集**，然后再执行回表操作，这样能省下一些回表的开销。**使用intersection索引合并有一个苛刻的条件，那就是数据记录必须是按照主键值排序的**（从排序的两个集合中寻找交集更加的简单；id有序利用顺序IO加快速度）.

- Union索引合并

```sql
select * from test where a = 'x' or b = 'y'   (假设有a和 b两个单独的索引)
```

对于上面的查询也可以使用同时扫描索引树a和索引树b，然后取二者结果之间的**并集**再去重。**如果不采用索引合并，只是分别单独使用两个索引会导致重复的回表操作**。在数据量少的情况下，Union索引合并要求数据是按照主键排好序的。