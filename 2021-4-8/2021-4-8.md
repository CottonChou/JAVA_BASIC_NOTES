## 什么样的情况下会发生死锁？如何解决死锁？

当并发系统中出现了循环依赖，设计的线程又在等待别的线程释放资源的时候就会导致着几个线程无限等待的状态。在InnoDB的事务中，行锁在需要的时候加上，等到事务释放的时候才释放，如果一个事务中需要锁住多个行，可能会造成锁冲突。

一种解决办法是直接等待，直到超时，这个不适合当前主流的在线服务，等待用户无法接受。

另外一种解决办法是发起死锁检测。InnoDB会在发生死锁的时候主动回滚代价较小的事务，代价较小的事务就是在死锁发生前更新操作比较少的事务。

但是开启死锁检测对于热点行的更新也是十分消耗CPU性能的。

假设某一行的并发度是1000，每一个来更新的线程都要检测一下就要看一下是否被锁住了，就是100万的数量级，对于热点行的数据更新可以考虑控制并发度，或者将行在逻辑上分拆。

每次发生死锁后，可以查看日志观察为何发生了死锁，看看是都可以在语句的执行顺序上优化一下，避免锁的竞争。

通过 show engine innodb status 查看最近发生的一次死锁信息，show engine innodb status 只会显示最近一次发生的死锁信息，可以设置全局变量 innodb_print_all_dead_lock 为 on，在错误日志里收集所有的死锁日志。

## MySQL 中 varchar 和 char 的区别是什么？

char 和varchar都是存储的字符，在UTF8编码中，一个字符占据两个字节。

VRACHAR除了存储真正的数据内容外，还会在行的头存储格外的信息，其中就有变长字段的的长度列表。

由于行是变长的，可能会某一行原来是存在一页里面的，后来更新放入了更多的数据，这个时候会发生页的分裂。

char是定长的，超过规定的字符数了会报错，有多余的空格会被截断，字符数不够会被天从空格。

对于一些比较短的列，char会比varchar更加有效率。

## left join inner join

有内连接外连接两种方式，连接的本质就是将各个表的记录都取出来一次进行匹配，并将匹配后的组合发送给客户端。内连接和外连接的根本区别就是在驱动表中的记录不符合ON子句的条件时，内连接不会把记录放到最后的结果集，而外连接会。

**left join 左外连接**：

左表右表连接，驱动表是左表（驱动表会访问一次，而被驱动表会访问N （n = 驱动表符合条件的记录）次）。如果右表没有符合条件的信息，会返回null进行填充。

## 模糊查询是如何实现的？

仅仅知道如何在索引列上进行模糊查询左匹配。

对于某个索引来说，字符串前缀的记录必定是相邻的，假设查询的语句是 like a%,显然只需要定位到符合 a前缀的第一条记录，然后沿着链表往后扫描，遇到第一个不符合的就可以结束了。那么 like a% 形成的扫描区间就是 ['a','b']

## 悲观锁 和 乐观锁

当我们要对一条数据加锁的时候，为了避免同时被别人修改，最好的办法就是加锁。修改之前先加锁，再修改的思想就是悲观锁。悲观锁确实避免了线程安全的问题，但是也带来了效率低下，操作不当右死锁的问题。

乐观锁是假设再并发的事务处理里面不会彼此影响，再提交数据更新之前检查是否有其他事务修改过该数据，如果有更新自己就回滚。

在数据库里面实现乐观锁可以增加一个version字段，

```sql
update xxx set xx = xx where version = xx
```

其实问题都是一样的，这样会导致再高并发的情况下，只有一个线程可以成功，其他大量的失败。在java里面可以减少乐观锁的粒度，数据库里面自然也有响应的办法。具体情况具体分析。