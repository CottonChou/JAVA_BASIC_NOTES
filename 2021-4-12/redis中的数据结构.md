> redis中有六种比较重要的数据结构，SDS，链表，字典，跳跃表，整数集合，压缩列表。redis的对象主要是靠这六种数据结构实现的。

## 数据结构

### 简单动态字符串（SDS）

Redis没有使用C语言中的传统字符串，而时自己构建了一种SDS的数据结构，在redis中包含字符串的键值对底层都是用SDS实现的。除此之外，AOF缓冲区，客户端状态的输入缓冲区都是由SDS实现的。

```c
struct sdshdr{
    //已经使用的字节数
    int len
    //剩余的字节数
    int free
    //字节数组，用来保存字符串
    char buf[]
}
```

带有未使用空间的SDS示例：

```json
sdshdr
free:5
len:5
buf ->['r','e','d','i','s','\0','','','','','','']
```

- 和c语言比起来，c的字符串不会记录自己的长度，去过想取c语言的字符串的长度要把整个字符串遍历一百年，时间复杂度是O(N)，redis直接记录了，时间复杂度是O1.（记录长度这不是基本操作吗，唉）

- C字符串不会记录自身的长度，所以在执行strcat等函数的时候可能会造成缓冲区溢出的问题，而在SDS中，进行此类操作会先检测是否出现缓冲区溢出的情况，然后再执行操作。

- C字符串不会记录自身的长度，所以再字符串需要增长或者缩短时，需要重新分配内存，这期间又缓冲区溢出或者内存泄露的问题。在sds中，采用了空间预分配和惰性空间两种优化策略。

  ​		空间预分配

  SDS需要扩展的时候，不仅会为SDS分配需要的空间，还会分配额外未使用的空间，减少连续执行字符串增长操作的需要的内存分配次数。

  惰性空间释放

  SDS需要缩短的时候，不会重新分配内存来释放多余空间，而时使用free字段将这些字节的数量记录下来，便于将来使用。同时也提供了释放空间的api，在需要的时候手动释放。

- 二进制安全

  二进制安全，C的字符串除了末尾之外，不能包含空字符，所以保存二进制数据的话，会误以为空字符是字符串结尾。而SDS是通过len属性来判断是否结束，不受空字符的影响。

- 兼容部分C字符串操作。

### 链表

由于C语言没有提供链表这样的数据结构，redis自己实现了双向链表。

链表在redis中的应用非常广泛，列表键的底层实现之一就是链表，当一个列表键中包含了比较多的元素，又或者列表中包含的都是比较常得字符串时，Redis就会使用链表作为列表键的底层实现。

Redis链表特性：

- 双端链表：双链表
- 无环：链表头节点的prev和尾巴节点的next指向null
- 带表头和表尾指针
- 带长度计数器
- 多态

链表应用广泛，列表键，发布和订阅，慢查询，监视器等等。服务器本身就使用链表来保存连接的客户端信息，也使用链表来构建客户端输出缓冲区。

### 字典

redis的数据库就是使用字段作为底层实现，字典的底层作为底层实现。

```c
//哈希表结构
typdef struct dictht{
    //哈希表数组
    dicEntry **table
    //哈希表的大小
    usigned long size;
    //掩码 计算索引值
    unsigned long sizemask
    //已使用的键值对树
     unsigned long used;
}
```

**字典结构**

```c
typedef strunt dict{
    dictype *type;
    void *private;
    dictht ht[2];
    //rehash索引，rehash不在进行的是皇后，为-1
    int rehashidx;
}
```

一般情况下，字典使用ht[0]哈希表，ht[1]只会在怼ht[0]rehash时使用。

rehashidx记录了rehash目前的进度，如果没有进行rehash，则为-1.

**发生扩容的条件**

服务器没有执行`bgsave`或者`bgrewriteaof`命令，并且负载因子大于等于1

服务器正在执行`bgsave`或者`bgrewriteaof`，并且负载因子大于等于5.

因为bgsave的时候，此时有一个子进程在进行cow。此时故意提高负载因子避免在cow期间存在hash表扩容操作，避免不必要的内存写入操作。

`负载因子 = 键值对的数量/size`

**发生收缩的条件**

负载因子小于0.1

扩容和收缩都通过rehash来完成。

**rehash步骤**

因为redis使用字典作为数据库的实现，所以rehash的过程不是一次性完成的，这样避免在迁移期间数据量太大给服务器的压力太大。`redis`采用的是渐进式hash主键的将ht[0]的数据慢慢的hash到ht[1]上。

- 为ht[1]分配空间(两倍扩容)，字典同时持有ht[0],ht[1]两个哈希表。
- 在字典中维持以合索引计数器变量rehashidx,将他的值设置为0，表示rehash开始。
- 在rehash期间，每次对字典的添加，删除，查找操作，程序都会额外的将ht[0]的元素索引上的所有键值对全部迁移到ht[1]上，本次工作完成，rehashidx+ 1。
- 随着这样的操作进行，最终总是会把所有的键值对rehash到ht[1]上，这个时候rehashidx设置成-1，rehash完成。
- 释放ht[0]，将ht[1]置为ht[0],在ht[1]上创建一个空链表。
- rehash的过程中，查询先查ht[0],没有查到再去查询ht[1]。插入一律保存在ht[1]

### 跳跃表

> 待续



