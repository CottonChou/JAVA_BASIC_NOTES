## redis的事务

> redis通过multi,exec,watch。

实现`redis`是通过multi命令开启一个客户端的事务的，当客户端发送multi命令给服务器，服务器会将这个客户端的实例的`redis_multi`打开，之后客户端发送给服务器的命令，除了和事务相关的`EXEC`,`DISCARD`,`WATCH`,`MULTI`会被处理，其他的命令一概加入一个队列。服务器执行命令就是将队列里面的命令出队依次执行完，尽管期间出错了也还是执行下去。然后返回结果给客户端。

### WATCH命令的实现

`watch`是一个乐观锁，可以在exec命令执行之前监视任意数量的数据键，并在exec执行的时候，检查被监视的键是否被执行过，如果执行过了，就会拒绝执行事务。

每个redis数据库有一个watched_keys的字典，key是watch的键值，value就是监视这个键值的客户端。如果此时对一个被监视的键进行修改的操作，那么redis会遍历监视这个key的客户端，将客户端的redis_dirty_cas标识打开，表示事务安全性已经被破坏。此时再接收到要求监视的客户端发来的exec执行，就会拒绝执行客户端的事务。

## ACID

**原子性**

通过队列保证一次命令序列化的执行，要不都执行要么都不执行，所以是符合原子性的。命令入队错误的话，所有命令都不会执行。

**一致性**

一致性指的是数据符合数据库本身的而定义和要求，没有包含非法的或者无法的数据。

如果一个事务在入队命令的过程中，出现了命令不存在或者命令的格式不正确等情况，那么redis拒绝执行这个事务。

如果在执行过程中发生了错误，也不会中断事务的执行。其他的命令正常执行。出错的命令不被执行。

如果在事务期间服务器宕机。那么只可能有两种情况。有rdb文件或者aof文件可以恢复，那么恢复后的状态还是一致的。如果没有，那就是空白的数据库，数据还是一致的。

**隔离性**

隔离性指的是，即使数据库中有多个数据有多个数据并发的执行，各个事务之间也不会互相影响，并发状态下不受影响。

redis是单线程的方式来执行事务，服务器保证在事务期间不会中断，因为redis的事务总是以串行的方式运行的。

**持久性**

持久性指的是事务执行完毕后会被永久性存储。

持久性和`redis`持久化策略相关。

就算是最严格`everySecond`模式，也可能会丢失最后一条命令。