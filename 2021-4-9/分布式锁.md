## Redis实现分布式锁

因为JAVA的锁受限于JVM，只能运用于单机，所以就需要引入第三方来实现锁。

> 要实现一个分布式锁首先要考虑的就是如何实现互斥，和防止死锁的问题，加锁和解锁必须是同一个线程或者进程。而且还要支持锁的可重入。

1. 指定一个key作为锁标记，存入redis,指定一个唯一的 用户标志作为value.
2. 当key不存在的时候才能设置值，确保同一时间只有一个客户端获得锁，满足互斥性。
3. 设置一个过期时间，防止因为系统异常没来得及删除，导致死锁。
4. 处理完业务之后需要删除这个key，删除的时候需要校验key，满足只有加锁的人才能解锁。



## redisson

redisson实现了JUC的lock接口，利用LUA脚本命令实现加锁，并且默认有效期时间是30秒。

而如果其他获取锁的线程失败，会订阅这个锁释放的事件，在这里，是利用jdk提供的信号量来阻塞线程的。如果等待过程中一直未等到锁释放时间就会超时返回。如果等到了锁释放的时间会继续循环尝试获取锁。

redisson还有一个看门狗的机制，一旦线程加锁成功，启动看门狗模式，看门狗模式是一个后台的任务线程，每隔锁的三分之一时间去查看这个线程是否还持有锁，如果持有则进行锁的续期。

可重入锁的实现思想和大多数的可重入类似，就是维护一个计数器，释放锁也是每次解锁计数器减1，为0则直接删除key，然后广播锁释放的消息并取消看门狗模式。

redisson很好的解决了锁重入和锁续期的问题，利用广播机制阻塞其他线程减少了无效的锁申请。

**缺点**

redisson的缺点就是可能在master实例完成了加锁，然后master在进行异步复制给slave的时候，宕机了，而产生的新master没有这个数据，可能会给其他的请求加锁，这样就导致了两个客户端获得了锁。

## RedLock

RedLock必须最少需要5个redis服务器，客户端每次申请加锁至少需要大多数服务器的同意，并且他是依次去访问每台服务器的，每次访问的时候都要减去网络访问和加锁锁消耗的时间，剩下的才是锁的有效期。如果获取锁失败，则要在所有的实力上释放key.

RedLock太重了，只是保证了锁的高可用，不能保证正确性。严格依赖于各个机器之间的时间同步，这在分布式的情况下是不太可能的，RedLock人为的又加了一点参数去修正时钟漂移，如果在计算锁超时或者持有锁的的时候发生了FGC导致的STW，明明锁已经超时了，然后gc完毕后又去提交了锁，影响了后续锁的申请逻辑。

