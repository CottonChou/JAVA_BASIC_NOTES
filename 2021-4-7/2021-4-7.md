## 脏读和幻读发生的场景，如何解决幻读



**脏读**

假设A正在读取一行数据，B正在修改，A读到了B修改后的数据，但是B又回滚了。简而言之就是读取到了另一个未提交事务的写记录。

如果另一个事务在写记录的同时暴力的加一把锁（MVCC另外一种解决思路），那么也不会发生脏读。

**幻读**

如果一个事务先根据某些搜索条件查询出一些记录，在该事务没有提交的时候，另一个事务写入了一些符合那些搜索条件的记录，可以是insert，delete,update，就发生了幻读。再次查询的时候，就发现结果不一样了。

MYSQL在可重复读的隔离级别下很大程度上解决了幻读，不能避免insert那种幻读类型。

幻读的本质别的事务在某个事务的查询区间插入了一个新记录，采用加锁的方式避免幻读现象有一点麻烦，因为读取的时候你不知道给谁加锁。但是间隙锁可以解决这个问题。

**Record Lock + Gap Lock **

Record Lock有共享锁和排他锁两种形式，可以解决update,和delete形式的幻读问题。如果是插入记录，因为插入的记录之前还是不存在的，所以需要用到间隙锁Gap Lock。间隙锁的作用仅仅可以防止再该条记录之前插入记录。那么如果查询条件是select * ,随时要读取最后一条记录，间隙锁就是可以加在每条数据页的伪记录上。每条数据页有一个最小伪记录和最大伪记录。如果查询的索引包含唯一索引的时候，nextKeyLock会退化成 RecordLock。