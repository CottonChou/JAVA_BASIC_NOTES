## JAVA垃圾回收算法中如何判断一个对象被回收?

首先JAVA中使用的是可达性分析算法，基本方式就是通过一系列GCROOTS为根对象根据引用的关系开始搜索，由此确定一个引用链，如果一个对象在搜索完毕后没有没有与引用链关联，则认位这个对象是不可达的，是可以被回收的。

如何确定哪些对象是GC Roots，是很好理解的。

- 比如在虚拟机栈本地变量表引用的对象，各个线程被调用的方法堆栈中使用到的参数，变量肯定是不能被回收的，所以可以作为GC Roots。
- 有虚拟机栈的情况，就以此类推，本地方法栈引用的对象也可以作为GC Roots.
- 一些常驻对象，比如基本类型对应的class对象，常驻的异常对象，系统类加载器。
- 所有被同步锁持有的对象，类静态属性引用的对象，方法区中常量的引用。

## 常见的GC回收算法

首先长久以来，java基于的分代收集理论。

根据经验得来，大多数的对象都是朝生夕灭的。熬过越多次垃圾收集过程的对象就存活的越久，根据这两条法则将堆内存划分为了新生代和老年代，容易消亡的对象放在新生代，老对象存放在老年代。在不同的区域有不同的合适的回收算法。

**标记清除算法**

标记清除算法是需要标记出来所有需要清理的对象，或者反过来也行。标记完成之后，清理掉所有垃圾。很明显标记和清理的时长与内存和垃圾对象的数量正相关，还会留下不连续内存碎片。导致之后分配大对象后，明明有空间却找不到一块连续的内存，而再次触发垃圾收集。

**标记复制算法**

标记复制算法真实为了解决标记清除算法面对大象时效率低的问题，最原始的版本是半区复制，也就是将内存一分为2，每次只使用其中一部分，发生一次垃圾回收后，将存活下来的对象复制到另外一块，然后再把已经使用过的区域一次清理掉。这样给大对象分配就不会有找不到连续内存的麻烦了。

缺点就是在存活对象很多的时候，复制对象开销大，如果按照半区复制的方式，实际空间利用率只有一半。JVM不是单纯的1：1分配，空间利用率没有浪费百分之50这么严重。

**标记整理**

标记整理就是要解决对象存活率高，复制对象开销大的问题。

标记整理不是全量复制存活的对象到另外一块内存，而是让存活的对象向一侧靠拢，然后清理。其实移动对象和复制对象到另外一块区域都有很大的从奥做负担，因为涉及到了地址的改变，需要停止用户线程。



综上所诉，移动对象需要停止用户线程，停顿时间长，不移动则有内存碎片，下次分配对象复杂了。CMS采用的是，平常使用标记清理，直到分配不下去大对象了，就标记整理一次。