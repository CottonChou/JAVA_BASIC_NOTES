## Java 类的加载流程是怎样的？

> Java类加载过程是指加载Java的字节码文件，Java的字节码必须通过类加载过程加载到JVM环境才可以执行，JAVA采用的是JIT编译和解释混合执行。混合执行大的模式是开始阶段先执行解释字节码的常规操作，省去编译时间，随着时间推进，JVM统计热点代码统计分析，识别出高频的方法调用，公共代码等等，转换成机器码，直接交给CPU执行。

Java类加载过程打开分为加载，连接，初始化三个阶段。

在类的加载阶段通过一个类的全限定名来获取其定义的二进制字节流，初不校验cafa babe魔法数，常量池，文件长度，然后将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构，这个方法区的运行时数据结构就是java.lang.class对象。

连接阶段会检查类型是否正确，静态变量是否合理，为静态变量分配内存，完成内存布局。

初始化阶段调用类的构造器方法，如果赋值运算你是其他类的静态方法，那么会立马解析另外一个类。会初始化继承树上还没有被初始化过的所有父类，会执行这个链路上所有没有被执行过的静态代码块，静态变量赋值语句。

详细参阅**虚拟机267页**

## 什么是双亲委派模式

> 对于一个类，都需要由加载他的类加载器和这个类本身共同确定他在Java虚拟机中的唯一性。

在JVM中，判断两个类是否相等，首先必须是由同一个类加载加载的，其次是同一个class文件。

**从虚拟机的角度来看**，只存在两种不同的类加载器。

- 一种是启动类加载器，C++实现，是虚拟机的一部分。
- 一种是所有的其他的加载器，独立于虚拟机，继承自`Java.lang.classLoader`

**从开发者的角度来看，**类加载可以细分为

- 启动类加载器：负责加载Java_home/lib文件夹下的类库
- 扩展类加载器：负责加载Java_home/lib/ext(或者是系统变量java.ext.dir指定)文件夹下的类库
- 应用程序类加载器：调用`ClassLoader.getSystemClassLoader();`获得的加载器。加载系统路径classpath指定的类库。

类加载时间的继承关系是通过组合实现的，应用类加载器继承于拓展类加载器，拓展类加载器继承于启动类加载器，启动类加载器是最顶层。如果要自定义的话，自定义的加载器的parent是应用类加载器。

而双亲委派是指某个特定的类加载器在接收到类的加载请求时，首先加载任务委托给父类加载器，依此递归，知道顶层的启动类加载器，如果父类可以完成加载，那么便加载返回，只有父类无法完成才自己加载。

这样做的好处在于Java类和随着他的类加载器有了优先级关系，保证了系统的基础类库的类能够被正常加载程序能够正常的运行。

## 破坏双亲委派模型

在一些场景下，比如数据库驱动的加载场景下，受到加载范围的限制，启动类加载器无法加载到需要的文件，顶级接口的设计需要子类去实现，因此此时只能委托给子类去加载。调用`Thread.currentThread().getContextClassLoader()`会优先考虑使用应用类加载器 。

然后在热加载的场景下，支持热加载的编译器也是使用的自定义的加载器来加载属于自己模块的类，而不经过父类加载器。