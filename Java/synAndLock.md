## synchronized 关键字底层是如何实现的？它与 Lock 相比优缺点分别是什么？

对于普通同步方法，synchronized关键字锁定的当前实例对象，对于静态方法锁定的是class对象，对于同步代码块，锁定的是括号里面人为指定的对象。

JVM基于Monitor的对象来实现方法同步和代码块同步。monitorexit插入到方法的结束的地方和异常的地方，便于结束正常释放锁。当一个线程执行到monitorEnter指令的时候，尝试获取Monitor的所有权，这个行为就是加锁。

synchronized的锁存在JAVA对象头里面，为了减少获得锁和释放锁以及阻塞线程的开销，JVM引入了偏向锁和轻量级锁。

**偏向锁**

当一个线程获取锁，会在对象头和栈帧的锁记录CAS存储线程的ID，后续该线程每次进入该代码块的时候，简单检测偏向的线程是否是自己，偏向自己，则再次获取锁成功，如果不是则锁立刻进入轻量级锁模式。

**轻量级锁**

虚拟机使用CAS操作将对象头的markword更新为栈帧的锁记录的空间，更新成功，则获取轻量级锁成功。解锁过程就是替换回去，替换成功便解锁成功。值得注意的是，如果其中一个线程获取偏向锁失败，则虚拟机将锁标志位更改为重量级锁，此时解锁的线程不仅仅要解锁，还要负责唤醒被挂起的线程。

轻量级锁在始终得不到锁的情况下，始终自旋浪费了CPU的资源。

## 与Lock相比

在引入了锁升级后的Syn锁性能不比lock锁差，因为以前没有轻量级锁的时候，往往都是阻塞线程在唤醒，涉及到了内核态的切换。syn是非公平锁，lock锁支持公平和非公平两种方式，lock锁支持等待可中断，当持有锁的线程长时间不释放锁的时候，等待的线程可以选择放弃转而去处理其他的事情。

lock锁支持绑定多个条件，在syn锁仅仅只能关联一个。如果想使用syn唤醒多个条件队列，必须多申请一个锁。

之所以优化后的syn锁性能会比lock好，是因为虚拟机无法判断谁持有了lock锁，无法进行锁粗化，锁消除等等。这导致无论什么代码块，使用lock锁，都会加锁，都会切换到内核态。

## java类加载过程

在加载类的时候，使用的是双亲委派模型。

主要是在启动之初进行类的加载，链接，初始化。

加载阶段读取类文件产生二进制流，转换为特定的数据结构，初步校验cafe babe，常量池，文件长度，是否有父类，然后创建对应的class实例。

链接阶段包括验证，准备，解析三个步骤。

验证文件格式，元数据，和字节码，符号引用。

准备阶段为静态变量分配内训并设定默认值。

解析类和方法确保类和类之间相护引用的正确性。完成内存结构布局。

初始化阶段执行类的构造器方法，如果赋值运算时通过其他类的静态方法来完成，那么要马上解析另外一个类。

在类加载并初始化的过程中，JVM会初始化继承树上还没有被初始化的父类，执行这个链路上的所有没有执行过的

静态代码。

## 双亲委派机制

双亲委派机制的工作流程是 如果一个类加载器收到了加载类的请求，首先不会自己尝试加载这个类，而是将请求委派给父类加载器去完成，因此最终的加载请求都会传送到最顶层的启动类加载器，只有当父类反馈自己无法完成这个加载请求，子加载器才会尝试自己去加载。

这样的好处就是java中的类跟随这样的加载顺序具有了优先级关系，保证java的基础类库。

层级关系：

bootStrap -> platForm -> application -> 自己实现的

## 破坏双亲委派模型

如果有java基础类型需要调用调回用户自己的代码，那么必须就要破坏这种加载顺序。

解决这个问题可以使用线程上下文类加载器，程序可以指定使用这个线程的上下文类加载器去做一些事情。

热加载。

## JVM 中内存模型是怎样的，简述新生代与老年代的区别？

程序计数器，虚拟机栈，本地方法栈，方法区，堆。

**程序计数器**

当前线程所执行的字节码行号指示器，字节码解释器的工作就是改变这个计数器的值来选取下一条要执行的字节码命令。由于多线程是通过线程轮流切换分配时间来实现的，因此为了线程切换后能够恢复到正确的执行位置，所以每个线程拥有一个独立的程序计数器。

**虚拟机栈**

虚拟机栈也是线程私有的，虚拟机栈描述的java方法执行的线程模型，一个方法的运行和 结束对应一个栈帧的入栈和出栈。

栈帧用于存储局部变量表，操作数栈，方法链接，方法出口等信息，局部变量表存放了各种基本类型（包括引用类型，返回类型）。数据类型以槽为单位存放。

**本地方法栈**

同虚拟机栈，只是调用的是本地方法。

**堆**

基本上所有的对象实例和数组都存放在堆里面。线程共享。

**方法区**

存储 类型信息，常量，静态变量，即时编译器编译后的代码缓存。

运行时常量池是方法区的一部分，class文件中除了有类的版本，字段，方法，接口等描述信息。还有常量池表，存放编译器的字面量和符号引用。常量池表将在类加载后放入方法区。

常量并非是编译才产生，String.intern()也可以。

**新生代和老年代的区别**

对象诞生之初在新生代，步入暮年进入老年代，同时老年代也接受新生代无法容纳的超大对象。

新生代的空间按照8：1：1。绝大部分对象在Eden生成，当Eden区装满的时候，触发YoungGC，在Eden实现清除策略，没有被引用的对象直接被回收。存活的对象放在Survivor区。如果Survivor容量不够用，直接移交老年代。还有一种方式是，有一个对象计数器，每次存活年龄加1，到达15岁也会晋升老年代。

老年代也放不进去，Full GC.

算法不同。新生代是标记赋值算法，老年代是标记整理。