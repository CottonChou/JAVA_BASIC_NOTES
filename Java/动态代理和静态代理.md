> 代理模式的目的是在不修改原有类方法的设计的基础上，对方法行为进行增强。

静态代理和动态代理最大的区别在于静态代理是在编译器就确定了，在程序的运行之前，代理类的class文件就已经存在了，知道到底有几个代理类，代理类的具体实现方式。而动态代理是在运行时判断的，在程序运行时通过反射机制动态生成。

JDK动态代理的要求是被代理的类必须要实现了接口，因为`jdk`动态代理的实现方式就是运行时生成一个类，继承你的接口，然后执行相关的方法。如果要对一个没有接口的类进行动态代理，那么可以使用`CGLib`。

Spring的AOP就是使用JDK动态代理和`CGlib`来实现。根据类有无接口来决定 使用哪个技术。



**JDK动态代理示例**

```java
/**
 * @Desc 接口类
 * @Author FuYouJ
 * @date 2021/5/1 16:46
 */
public interface IProxyTest {
    String originalMethod();
}
/**
 * @Desc 被代理的类
 * @Author FuYouJ
 * @date 2021/5/1 16:47
 */
public class OriginalClass implements IProxyTest {
    @Override
    public String originalMethod() {
        System.out.println("啦啦啦啦");
        return "原始的执行动作";
    }
}
/**
 * @Desc 代理策略
 * @Author FuYouJ
 * @date 2021/5/1 16:49
 */
public class OriginalHandler implements InvocationHandler {
    private OriginalClass originalClass;
    public Object bind(OriginalClass originalClass){
        this.originalClass = originalClass;
        return Proxy.newProxyInstance(originalClass.getClass().getClassLoader(),originalClass.getClass().getInterfaces(),this);
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("方法之前拦截");
        Object invoke = method.invoke(originalClass, args);
        System.out.println("方法执行之后");
        return invoke;
    }

    public static void main(String[] args) {
        OriginalHandler handler = new OriginalHandler();
        IProxyTest proxyTest = (IProxyTest) handler.bind(new OriginalClass());
        proxyTest.originalMethod();
    }
}
```

