## HashMap的实现原理

> 以下内容摘选之阿里技术的文章。

简单说一下HashMap的几个核心特性。

**自动扩容**

满足最小可用原则，在容量超过一定阈值的时候才会扩容。

扩容的时机在添加元素之后，写入元素之后才会扩容，当自增size大于计算好的阈值threshold,执行resize方法。

当然如果是批量添加另外另外一个map的值，当然是要提交计算好并设置容量，从而避免频繁的扩容。

一般来说，扩容的速度是二倍速度扩容。这是保证数组的容量始终是2的幂。

扩容存在三种情况。

1. 当数组索引处只有一个元素，直接扩容即可。
2. 当数组索引处的节点是红黑树，执行红黑树的扩容操作。
3. 当数组索引处事链表，在这里有了一点优化，解决的是JDK7中头插法并发扩容死链的问题。进行高低位链表扩容操作。

在扩容的时候，容量增大一倍。例如容量从8变为16，那么【0，7】就是低位，【8，15】就是高位。

扩容的时候遍历数组的每一个节点，如果这个节点事没有冲突的，也就是没有拉链过，直接copy节点重新hash计算到新的位置。如果存在冲突元素，就是用高低位链表。意思就是先计算这个位置的hashcode，如果计算出来处于低位，则说明此节点扩容后的位置不变，使用低位链表将这些元素连接起来，如果计算出来处于高位，则使用高位链表连接这些元素。最后再将高低位链表的头节点分别放入新数组的对应位置。在之前是每次遍历一个元素就使用一次新数组，导致了死链。jdk8这种方式降低了对共享资源新数组的访问频率，减小了了死链的概率。

**初始化和懒加载**

初始化的时候不会立即对hash数组初始化，而是在第一次put元素的时候，初始化。如果没有指定容量，则默认的容量是16，扩容的阈值是12.

**hash计算**

我们确定一个元素的值，一般使用他的hashcode对数组长度取模确定位置，hashmap对原生的hashcode进行了一次扰动，将高16位和低16位进行亦或计算，将高位的特征融入到低位，降低了hash冲突的概率。

**hash冲突**

解决hash冲突的办法是拉链法，即如果对应的地方已经有了节点，但是二者的key不同，会基于已存在的元素拉出一条链表。当整体元素个数大于64且单链表长度大于8的时候，会将链表转化为红黑树。尽管hashmap的查询插入的期望值是O（1），但是冲突严重的时候，链表的时间复杂度是O（n）,将链表转换为红黑树将时间复杂度降到了ologn。我对AVL树和红黑树仅仅有过一点了解，AVL树保持严格的左右子数高度差不大于1，查询性能更好，但是为了保证高度平衡，AVL树再添加的时候，调整的元素可能更多。avl树适合写少读多的场景。在map中读写频率难分伯仲，所以采用红黑树。

因为计算hash的方式是位运算code & （n-1），比单纯的求模来的更快，而且为了hash后的结果均匀，才确定了数组长度必须是2的幂。n = 8,n-1 = 0111,任何与操作都会落到0到7，如果N=7，n-1=6,任何与0110进行&运算会落入到第0、6、4、2.利用率不足，还提高了hash冲突。

**并发**

HashTable使用了全局锁，任何操作都是基于同一个对象锁，效率极其低下。ConcurrentHahMap的数据结构形式和HashMap一致，在JDK8中采用的是**CAS**和**Synchronized**。

当添加的元素在 hash数组中不存在的时候，直接CAS操作写入。如果存在hash冲突，就是用synchronized锁住头节点，再添加元素。这样相比于分段锁，锁的粒度更细了，并发性能更好。

此外，consurrent使用的计数器并发求和使用的是LongAdder同样的思想，一般的多线程保证一个变量使用的volatile加CAS，但是这样在竞争激烈的时候，会让自旋的CPU变多，浪费了资源。LongAdder将变量打散最多和CPU数量一致的CountCell数组，然后让线程区处理对应数组的变量，降低了单纯一个变量竞争度，减少了CAS失败次数，求和的时候再遍历CountCell数组求和。

