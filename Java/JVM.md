## YGC,OldGC,FullGC,MixGC

GC分为两大类，分别是partial GC 和Full GC

partial GC指部分收集，分为YGC ,OldGC,mixGC

YGC :收集年轻代

OldGC: 收集老年代

mixGC: 这个是 G1 收集器特有的，指的是收集整个年轻代和部分老年代的 GC

Full GC整堆回收，回收整个堆，包括年轻代，老年代，永久代。

## YGC的回收条件

在年轻代的 eden 快要被占满的时候会触发 young gc。

eden 快满的触发因素有两个，一个是为对象分配内存不够，一个是为 TLAB 分配内存不够。

## full gc 触发条件有哪些？

- 在要进行 young gc 的时候，根据之前统计数据发现年轻代平均晋升大小比现在老年代剩余空间要大，那就会触发 full gc。
- 有永久代的话如果永久代满了也会触发 full gc
- 老年代空间不足，大对象直接在老年代申请分配，如果此时老年代空间不足则会触发 full gc。
- 担保失败即 promotion failure，新生代的 to 区放不下从 eden 和 from 拷贝过来对象，或者新生代对象 gc 年龄到达阈值需要晋升这两种情况，老年代如果放不下的话都会触发 full gc。
- 执行 System.gc()、jmap -dump 等命令会触发 full gc。

## TLAB 

一般而言生成对象需要向堆中的新生代申请内存空间，而堆又是全局共享的，像新生代内存又是规整的，是通过一个指针来划分的。采用指针碰撞的方式分配内存，也就是CAS比较，在并发的时候，性能不太好。所以采用Thread Local Allocation Buffer,为一个线程分配的申请区域。

TLAB预先划一块区域给一个线程，这样每个线程只需要在自己的那亩地申请对象内存，不需要争抢热点指针。

当这块内存用完了之后再去申请即可。

TLAB 只能分配小对象，大的对象还是需要在共享的 eden 区分配。

所以总的来说 TLAB 是为了避免对象分配时的竞争而设计的。

## PLAB

PLAB 即 Promotion Local Allocation Buffers。用在年轻代对象晋升到老年代时。

在多线程并行执行 YGC 时，可能有很多对象需要晋升到老年代，此时老年代的指针就“热”起来了，于是搞了个 PLAB。

先从老年代 freelist（空闲链表） 申请一块空间，然后在这一块空间中就可以通过指针加法（bump the pointer）来分配内存，这样对 freelist 竞争也少了，分配空间也快了。

## 新生代的 GC 如何避免全堆扫描？

在常见的分代 GC 中就是利用记忆集来实现的，记录可能存在的老年代中有新生代的引用的对象地址，来避免全堆扫描。

HOTSPOT里面记忆集的实现是卡表。

将堆内存按照512字节单位分组，一组一卡。通过写后屏障来维护卡，类似于AOP的一种方式，在引用赋值的时候判断是否是老年代引用了新生代，是就加入到卡表。而CMS为了性能，没有这个判断条件，直接在引用的时候就添加到卡表。同时，这个添加的动作被放在了队列里面，异步执行。

## Java 线程和操作系统的线程是怎么对应的？Java线程是怎样进行调度的?



##  G1 回收流程

## CMS回收流程



