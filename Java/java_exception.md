## Java的异常体系

> JDk定义了一套完整的异常体系，所有的异常都是Throwable的子类。分为error和Exception。

**Error**

> error是指致命异常，发生此类异常都是系统发生了不可控的错误，程序已经无法处理，需要人工干预了。比如OOM,StackOverFlow.

**Exception**

> exception异常类型才是跟程序息息相关的异常。exception分为checked受检异常和unchecked未受检异常。

- **checked**

1. 受检异常必须在程序里面显示的处理，否则会编译出错。处理方式有两种，一种是自己能处理的在catch代码块里面处理，一种不能处理的抛给上层，让调用者考虑处理。
2. 尽管是受检异常也有可能在程序里面由处理不了的时候，比如关于SQL的异常，字段太长，死锁故障等，这种只能保留程序现场，等人工介入解决。

- **unchecked**

> 未检查异常全部都是RuntimeException的或者他的子类。

**未检查异常的处理方式有三种**

1. 不抛出也不处理

   比如指针越界空指针虽然属于运行时异常，但是可以通过良好的编码习惯来预防。这类异常既不要显示的处理也不要抛给应用线程，因为这本来就是可以通过提前检查就可以避免的问题。

2. 需要捕获处理

   比如服务之间调用的超时，需要捕获该异常对接口进行一定程度的重试或者是其他处理（服务降级）。

3. 可以透出（直接抛，但是不是通过throws修饰方式）

   可透出的异常并不是指将异常通过throws层层往上抛出,而是指应用和框架会自行处理。

> 对于一些特别的操作，比如IO操作和加锁操作，是推荐使用在finally里面做善后工作，但是不要在finally里面做赋值操作。

## 异常的抛与接

> 异常的抛与接需要严格遵循约定，要使捕获的异常与抛出的异常完全对等或者是他的父类。

在我们的系统里面最开始第一是没有异常做一个规约，什么时候应该返回什么，比如针对NPE到底返回空对象还是空指针。异常的传递在服务之间也没有得到保证，经常调用一个服务被调放发生了异常，调用方无法感知是什么异常，这导致被泛化处理，抛给用户的异常就变得模糊，定位问题也变的艰难。

推荐对外提供的接口使用错误码，公司内部调用优先考虑使用Result对象来封装错误码，错误描述信息。应用内部直接抛出异常即可。

之所以推荐内部服务调用使用Result对象封装，是因为如果采用抛异常的方式，调用方如果没有捕获的话，可能导致运行时错误，导致程序中断。

对于空指针异常时采取返回null的方式，因为想强调调用方对对象进行非空判断，如果采用返回空对象，调用方会松懈这个意识，可能在被调服务挂了连空对象都没得返回的情况，那么此时直接拿来即用的话，调用方也会疯狂的NPE。

- 尽量不要捕获类似Exception这样通用的异常，而应该捕获特定的异常

  但是如果你什么异常都用了Exception，那别的开发同事就不能一眼得知这段代码实际想要捕获的异常，并且这样的代码也会捕获到可能你希望它抛出而不希望捕获的异常。

- 不要延迟处理异常

  延迟处理异常会导致出错的链路太长，堆栈信息过多。

- 只在需要try-catch的地方try-catch，try-catch的范围能小则小

  只要必要的代码段使用try-catch，不要不分青红皂白try住一坨代码，因为try-catch中的代码会影响JVM对代码的优化，例如重排序。

- 不要通过异常来控制程序流程

  一些可以用if/else的条件语句来判断例如null值等，就不要用异常，异常肯定是比一些条件语句低效的，有 CPU 分支预测的优化等。

  而且每实例化一个Exception都会对栈进行快照，相对而言这是一个比较重的操作，如果数量过多开销就不能被忽略了

- 不要在finally代码块中处理返回值或者直接return

  在finally中return或者处理返回值会让发生很诡异的事情，比如覆盖了 try 中的return，或者屏蔽的异常。